번역이 불안정해 미완성 [*] 


개인적으로 윈도우7에 설치할 프로그램 목록

 1.IDA		2.x64dbg, windbg 	

 3. PE 분석툴 [ 아래는 목록 ]

 - PEView (무료, 데이터 수정 불가능)
 - PE Explorer (상용)
 - Stud PE (무료, 데이터 수정 가능)
 - PE Browse (무료, 데이터 수정 불가능)

 4. Process 관리 툴

 - process explorer --> Aslr , dep 확인 및 프로세서 확인 가능 

 5. 권한 확인 툴 
 
 - winobj.exe

최근 수정 : 2018/09/05 

-C1-  요약

	self-protection
	-커널 단계 에서 자체 구현 하는 백신이 많음 
	-일부 백신은 유저 단계에서 구현한다.
	
	AV는 커널 단계에서 사용하는 기능이 들어가있음
	검색엔진, 서명, 압축풀기, 에뮬레이터 지원

-C2- 리버싱

	사용 툴 : IDA, IDA python, windbg, gdb, winelib, bindiff, pydbg[*] 

	IDA : 정적 분석에 사용
	IDA python : 자동화
	windbg : 동적 분석에 사용
	gdb : 리눅스 버전 동적 분석	
	winelib : 리눅스 버전에서 동적으로 커널 드라이브 분석할때 사용
		  { 시리얼 통신 }
	bindiff : 바이너리 비교 툴 
		  { 리눅스에서는 심볼이 살아있을수도 있음 이걸 windows 버전으로 옮겨서 쉽게 분석 }
	

	백신 일부는 중압 집중식 서버에서 실행하게 설계 되어있음
	
	커널 디버깅을 위해 가상머신을 사용한다 -> 운영체제 부팅 옵션 제한
	
	bcdedit /debug on : 커널 디버깅 사용
	bcdedit /dbgsettings serial debugport:1 baudrate:115200 : 글로벌 디버깅 설정 및 시리얼 통신 속도 설정
	
	가상 머신에서 시리얼 통신 포트를 개방 해줌 COM1 포트	
	- COM1 포트와 가상머신 커널 통신

	.sympath srv*http://msdl.microsoft.com/download/symbols
	.reload
	-> windbg 재로드
	
	!process 0 0 -> 커널단 프로세서 나열

	!process 0 0 fssm32.exe -> 이름으로 나열 
	--> PROCESS [주소] : [주소]는 eprocess 의 구조체

	.process /r /p [eprocess] -> 모든 심볼 나열

	
	[ 퍼징은 리눅스에서 더 빠름 ] 

	

	대부분의 안티 바이러스는 서버로 파일의 해시검사 하고 전송해 파일이 악성 코드인지를 검증
	이때 통신 소켓 파일을 찾아 소켓을 생성하고 직접 파일의 해시를 전송함으로서 백신 서버와 통신 가능

	
-C3- 플러그인 로딩

	플러그인 로딩은 R,W,X 메로리 페이지에 할당된다. 
	
	할당된 메모리가 적절하다면 내용과 해독 및 압축을 해제 한다. 

	이후 쓰기권한을 삭제한다, 또한 플러그인을 dll 파일로 제공하여 단순화 시킨 데이터를 난독화 시킨다. 
	
	-memory Scanners 
		userland = openPorcess, ReadProcess memory : win32API 를 사용하여 제공한다.
		kernel = IOCTL : AV 회사가 직접 만ㄷ르어 사용해야함

	플러그인은 스크립트로 작성될수있음 => lua script, .net
	커널 드라이버는 C or C++, 일부는 .net

	.net 으로 작성되어있으면 머리가 아파진다고 한다. 이에 대한 방법
		- 1. 코드가 가상시스템용인지 식별 한다.
		- 2. 가상 컴퓨터가 지원하는 전체 명령 집합 확인
		- 3. 플러그인의 루틴 바이트가 위치한곳을 덤프
		- 4. 특정 가상파일에 구현된 플러그인 분석 시작


-C4- 안티 바이러스 시그니쳐의 이해

	우회방법 1. 서명에 1byte를 추가 하는 방법 ( 해시를 비교하는 부분 우회 ) : 해싱 비교 기법 : ssdeep 프로그램 동작 방식 사용 
	

-C5- 업데이트 시스템

	서명을 다운로드할땐 http, https, 간혹가다 ftp[오래된 제품] 
	
	해시를 보고 오래된 버전과 새로운 버전을 구별하여 다운로드 받음
	책에선 해시만 다르면 다운로드 받는다고 적혀있음

	ssl 통신 중 가능한 공격 기법
	
	1.domain name system 변경 가능할때 
	- > 당연하게도 악의적인 파일 다운로드 시킴
	
	2. MITM
	- > 같은 네트워크 망에 있으면 파일을 수정 하여 공격가능 

	

	ssl 통신 중 발견될수 있는 취약점
	- > server 의 인증서 호가인 없이 SSL/TLS 사용
	- > CA 인증기관이 없을경우 [자체 적인 사용] --> MITM 가능
	- > 유효 하지만 만료된 인증서 수락 

	[Verifying the Update Files]
	- > 번역문제 때문에 보류

	업데이트 패킷 조사
		1. 와이어 샤크로 패킷 캡쳐

		2. xml 파일과 대조

		3. 프로토콜 분석

		4. 취약점 탐색[서명 체크] 

	보안을 신경쓰지 않은 업데이트는 인증서 관련 공격에 취약할 수 있음
	예전 사례로 디피 헬만 키교환이 8비트로 구성되어 쉽게 공격이 가능


-C6- 안티 바이러스 소프트웨어 우회 


	바이러스 탐색 기법
	1. 알려진 바이러스 해시 검사
	2. PE헤더 조사 --> 오프셋 으로 검사함 내용이 추가 되어 있는지
	3. 인스트럭트 검사



-C7- 전자서명 우회방법
	1. 바이러스인지 탐색하는 부분에서 로지컬 에러를 찾는다. 책에선 사이즈를 비교하는 분기문을 통과 시켰다. 
	[PE]
		-PE file 
			- PE 파일은 다른 프로그램 없이 자체적으로 실행 가능한 프로그램을 말한다.
			- [오역 일수도 있음] PE 파일은 파일자체를 손상시키지 않고 변경할 수 있는 방법이 많다.
		[section name]
			바이러스 검사시 섹션 네임을 보고 검사를 하는 백신이 존재한다. 이 부분을 수정할수도 있는것 			  같다.
		[TimeDateStamp] 
			시간으로 바이러스 탐지 증거로 사용하지만 이 타임데이트스탬프 영역은 마음대로 변경가능하고 			  NULL로 변경 까지 가능하다.
		[Major/Minor operatingSystemVersion]
			이 친구는 타임데이트스탬프와 완전히 일치한다고 합니다.
		[File Length]
			파일이 비정상적으로 크면 어떤 백신은 검출을 무시하기도 함, 이유는 대부분의 바이러스가 용량			  이 작기 때문임 

		[****] PE탐지 우회는 정말 많은 방법이 있다. 때문에 작성자도 Ange Albertini의 wiki를 확인하란다.


	2. 자바 스크립트 
		많은 악성 코드들은 자바 스크립트로 제작 되어 있음
		
		첫번째로 문자를 인코딩 하는 방법이다. XSS,Sql injection 등 우회 방법과 동일	
		
		두번째로 코드 삽입 기술이다. 많은 문자열을 입력받고 실행하는 코드가 존재하기 떄문에 이런 방법도 된		  다고 한다.
		
		세번째는 자바스크립트 로지컬에러 정크코드 실행 부분인데 이해가 안간다. 번역이 어렵다; [*]

	3. PDF
		-1.PDF는 엄청난 헤더와 크기 떄문에 안티 바이러스에서 검출이 사실상 불가능하다.
                 때문에 hash 검사하는 기법을 사용한다. 
		pdf에 사용되는 공격코드는 자바스크립트가 대부분 유형이며 자바스크립트의 모든 문자열을		    		  인코딩 시켜서 올리는 방법이 있다. 이렇게 되면 hash는 달라질것이고 우회가 가능하게 된다. 
		
		-2. PDF 우회 [number] [number2]  obj  ~~~ endobj 형식으로 구성되는데 [number]가 동일하다면 맨 아래 		      선언된 형식을 따라간다. 이런 중복 오브젝트 방식을 백신이 이해하지 못하고 있다면 이부분에 쉘 코			드를 추가하여 공격이 가능하다. 
		    
		--> 이 파트는 스캐너 탐지가 아닌 서명 탐지를 우회하는 기법이다 


	    


	
	
-C8- 스캐너 우회방법

	들어가기 앞서 7장은 서명을 우회하는 방법이라면 8장에서는 PE파일 전체를 우회하는 방법에 대해 논하는 부분이	  다.
	
	finger printing -> 이 부분은 comodo 안티 바이러스 기능중 지문인식 암호화 부분을 말하는데 이 부분은 따로
	요약을 하지 않았습니다.
	

	Target : ClamAV의 PE parser 모듈

		- windows xp 버전에서는 PE 파일에 섹션이 96개 이상 존재하면 PE 파일이 깨진상태로 인식한다.
		  windows vista 버전으로 넘어오면서 섹션의 크기는 커졌고 이에 대한 대응이 없었던 백신은 취약점			    이 생기는 부분을 노렸다.

	안티 에뮬레이터 : [*] 이해를 못하겠습니다. # anti emulator 공부 요망

				1.windows 에서 기본 제공하는  SetErrorMode() 함수를 통해 안티 에뮬레이팅을 했다. 
				[고전적인 방법] -> SetErrorMode 를 한번 선언하고 재호출 하는 코드는 안좋은 코드다
				--> 잘못된 구현 코드를 설명 하는듯 하다.
				또한 null 값을 매개 변수로 특정  API 트리거에게 전달하면 에뮬레이트 되지 않은 환경
				에서는 액세스 위반 예외처리가 된다. 
				
	8장은 회의후 질문 내용을 추가하여 다시 적을 예정입니다. 






-C9- 지능형 엔진 우회 방법
	
	
	
		휴리스틱 알고리즘 : 휴리스틱 알고리즘은 가용한 정보를 기반으로 분기단계에서 어느 한 분기를 선택 하기위해 사용하는 다양한 탐색 알고리즘의 대안 함수 
		

		휴리스틱 엔진 및 백신에서의 휴리스틱 정의 : 휴리스틱이란 백신에 정의 되어 있지 않은 악성 코드 외에 악성 행위를 하는 코드를 탐색하고 진단하는 기능이다. 정의가 되어있지 않으므로 오탐률이 높다고 한다.
	
		휴리스틱 엔진은 크게 정적, 동적, 하이브리드 방식과 같은 3가지 유형이 존재함 

		책에서는 두 가지 전략을 모두 사용하는 방면으로 접근을 시도, 정적인 휴리스틱 엔진이 흔히 말하는 휴리스틱 엔진이며 동적으로 탐지하는 휴리스틱 엔진은 HIPS 라고 한다. 

		정적인 방법에서는 헤더를 분해하고, 분석하고 증거를 정적으로 발견한다.
		동적인 방법에서는 프로그램 동작 부분에서 API 호출을 주로 본다고 한다.

		


		1.  정적인 휴리스틱 엔진
		
			정적인 휴리스틱 엔진은 다양한 방법으로 구현됩니다.
			
			컴퓨터에 학습 알고리즘을 구현하여 유사성에 대한 정보를 기준으로 탐색하는 기법 --> 이 기법은 크기가 큰 멀웨어를 타겟으로 만들어졌습니다. 하지만 이러한 클러스팅으로 제작된 휴리스틱 엔진은 오탐률이 높고 큰 컴퓨팅 자원을 소비해서 그다지 성능적으로 좋지 않은것을 말하고 싶은것 같다.

			
			두번째 알고리즘은 사람의 의지가 들어가는 엔진이다. 간단하게 헤더를 분석하고 난독화, 안티디버깅 같은 기술들이 들어가 있고 프로그램이 자체를 보호하려고 한다면 사용자에게 이 프로그램을 사용하거나, 압축이 되어있거나 이런 정보를 물어보고 이러한 사람의 판단, 경험을 기준으로 제작하는 알고리즘이 있다.

		
			본 저자는 comodo 백신을 기준으로 linux 에서 ida로 분석을 시도했고 심볼은 libHEUR.so에 구현되어있다. 때문에 심볼을 살려 분석이 가능했고 이 토대로 분석을 시작한다.


			저자는 SCANHEUR 함수 부분을 추적 했고, 코드 부분이 어떠한 파일은 언패킹을 열심히하는 부분을 찾게 되었다. 찾던 도중 화이트 리스트가 하드 코딩된 부분과 대조를 하여 판별 하는 부분이 있는데 이 부분을 찾아 악성코드 PE 에 추가 해주면 간단히 우회가 가능했다. 
			

			두번째로 우회해야 하는 부분은 슈도 코드에서 나오는 확장자를 검사하는 부분이다. 
			하지만 이 부분은 하드 코딩 되어있기 때문에 .cpl 과같은 확장자로 하드코딩에 없는 실행 파일로 쉽게 우회 가능하다.

			
	

		2. 동적인 휴리스틱 엔진 

			동적인 휴리 스틱 엔진은 OS에서 제공하는 API에 의존해 성능이 크게 좌우 된다고한다.
			또한 CPU 에뮬레이터 의 성능도 많이 좌우 한다고 한다.

			일반적으로 HIPS 과 같은 후크 기반 휴리스틱을 우회 하는 방법은 쉽지만 API 훅이 설치된 레이어에 따라 난이도가 결정 되는것 같다. 프로그램 동작을 모니터링 하기 위해 훅을 설치하는 두가지 방법이있다. userland 훅과 kernel land 훅이 있다고 한다. 둘다 장단점이 존재한다.



			Userland - Hooks :
				
				많은 안티 바이러스 제품은 사용자 영역 후크를 사용해 실해중인 프로세스 실행을 모니터링한다. 후킹은 windows API 중 createfile, createPorcess와 같은 일반적인 API를 우회하는 것으록 구성 된다.

				Hooking engine :
							madcodeHook - delphi 로 작성됨, 다양한 런타임 지원, commod, McAfee 백신에서 사용됨

							EasyHook - 오픈소스 후킹 엔진이다, 좋은 성능과 완성도를 자랑하며 일부 바이러스 백신은 이 엔진을 사용하고 있다.

							Detours - 마이크로소프트 리서처의 독점적인 후크 엔진이다 소스코드를 사용할수 있지만 라이센스 구매를 해야하며 상업 제품 일부는 이 엔진을 사용하고 있다.

							하지만 이런 후킹엔진이 어느 백신에 쓰이는지는 무의미하다고 한다. (그럼 왜 알려준걸까..?)



				API 훅 처리 순서 :
						

							1. 모니터링을 원하는 사용자 프로세스에 라이브러리 주입 일반적으로 후킹 라이브러리는 모든 프로세스에 주입되므로 사용자 영역 프로세스를 시스템 차원에서 모니터링 한다. 


							2. API를 처리하기위한 바이러스 백신 코드를 함수의 첫번째 어셈 명령어를 점프로 대체 한다.

							3. API에 대한 바이러스 백신 코드 후크가 실행된다.

							4. 후크가 실행된 후 원래 코드로 돌려준다.

				과거 안티바이러스 후킹 라이버르리, 또는 주입할 라이브러리를 Appinit_dll 레지스트리 키를 사용하는것이었다. 이 레지스트리 키에는 삽입할 DLL에 대한 경로가 들어있고 user32.dll을 가져오는 모든 프로세서에 주입하는것 같다. 
				

				두번째 인기 있는 방법은 windows 데스크톱 시작시 바이러스 백신 프로그램 구성 요소를 실행하고 createremoteTread를 통해 explorer.exe 프로세스에 코드를 삽입 한다음 CreateProcessInternal 함수를 연결 한다. 이때 이함수는 새 프로세스를 만들려고 할때마다 실행 하게 된다. 하지만 이 API는 연결 형식이라 후킹 DLL이 새프로그램의 메모리 공간에 주입하도록 설계 되어있다. 하지만 이 기술은 createremoteTread API의 제한으로 인해 모든 새 프로세스가 모니터링 될거라고 보장 할수가 없다, 하지만 이럼에도 불구하고 이 방법은 다양한 바이러스 백신 제품에서 계속 사용된다고 한다. 

				DLL을 주입하기 위한 마지막 전형적인 접근법은 커널 랜드에서 수행하는 기법이다. 커널 랜드에서 psSetcreateProcessNotifyRoutineEx 콜백을 등록하고 모든 새 프로세스에 대해 커널 랜드에서 userland 코드가 들어간 dll을 주입하는 기법이다. 

				어쨋든 모든 후킹 엔진은 어떻게 뿌려주는지에 관계없이 동작은 거의 비슷하기 때문에 이를 우회하는 보편적인 기술을 개발할수 있다고한다. 


				이 우회 기술은 함수의 프롤로그를 덮어서 바이러스 백신 대체 기능으로 이동해야 하므로 변경 사항을 간단히 돌릴수 있고 또한 hook을 취소 할수도 있다고 한다. 이 개념을 명확하게 설명하기 위해서는 프레임 기반 함수의 프롤로그는 동일한 바이트 코드 시퀀스 또는 기계어가 있음을 알아두는게 중요한다. [ 난 이게 도대체 무슨 말인지 모르겠다. 아래있는 푸시 이비피 무브 이비피 이에스피를 알아야한다는건지 잘 모르겠다. ]


				후킹을 취소하는 빠른 방법중 하나는 바이트 시퀀스를 하드 코딩 하는 방법이라고 한다. 우회 코드에서 프롤로그 기능을 수행 한다음 함수의 시작 부분을 덮어 쓰는 방법이다. 하지만 이 프롤로그와 후킹된 함수의 프롤로그가 다른 경우 이러한 방법은 실패할수도 있다고 한다. 


				후킹 취소 하는 방법:

					1. 디스크에서 kernel32.dll, ntdll.dll 등 원본 라이브러리를 읽어옵니다. 
					2. 라이브러리에서 후킹 된 함수의 주소를 알아낸다. 이때 dbgeng.dll을 사용하여 알아 낼수 있습니다. dll export 테이블을 보고 주소를 찾아낸다.				
					3. 알아낸 함수의 초기 바이트를 읽는다. 


					4. 원래 바이트를 다시 메모리에 쓴다. 바이러스 백신이 패치를 알수 있습니다? [ 이부분 뭔말인지 모르겠음 ] 이에 대한 대안으로 첫 번째 명령어를 읽어 온다. 그 파일을 원래의 코드를 다시 이동하면 된다. [ 그냥 함수의 바뀐 바이너리를 원래 바이너리로 바꿔주면 된다는 내용 같다. ] 


				Userland HIPS 우회 :

					Comodo internet Security 버전 8 버전  HIPS를 분석
					
					저자가 첫번째로 사용한 방법은 가장 쉽고 빠른 HIPS 휴리스틱 엔진을 비활성화하는 방법을 선택했다. 훅 라이브러리를 언로드하는 방법이 있다고 한다.


					32 비트 경우 guard32.dll 64 비트 의 경우 guard64.dll 이 필요하다고 한다. 작성자는 FreeLibrary(GetmoduleHandleA("guard32.dll")) 로 만들었다고 한다.
					하지만 이러한 방법은 언훅이 되어지지 않는다. 오류값 5를 리턴하고 작동하지 않는다. 때문에 GetProcAddress(GetModuleHandleA("ntdll.dll"),"LdrUnloadDll") 함수를 사용해 ntdll.dll 레벨에 걸린 후크를 제거 해주어야 한다. 이후 이전 FreeLibrary 함수를 호출 하면 된다고 한다. 

					




			kernel-land - Hooks :
				

				안티바이러 제품은 크게 3가지 함수를 콜백해 프로세스, 혹은 쓰레드 생성을 커널단계에서 후킹할수 있다.

				PsSetCreateProcessNotifyRoutine = 요소를 추가 및 제거 가능, 프로세스가 생성되거나 삭제될때마다 호출되는 루틴 목록

				PsSetCreateThreadNotifyRoutine = 드라이버가 제공하는 콜백을 등록. 새 스레드가 작성되거나 삭제 될때 행동 이후 통지

				PsSetLoadImageNotifyRoutine = 다라이버가 제공 하는 콜백을 등록, 이미지가 로드 되거나 매핑 될 때마다 행동 이후 통지 


				이러한 커널 엔진은 유저랜드 단게에서 실행 되는 멀웨어는 이를 우회할수 없었지만 커널 단게에서 실행되는 멀웨어는 이가 가능하다고 한다.


				예시:
					1. 멀웨어는 드라이버를 설치하거나 커널 수준의 취약점을 악용하여 ring-0 에서 코드를 실행한다. 멀웨어는 문서화 되지않는 PspcreateProcessnotifyRoutine에 대한 포인터를 얻는다.
					2.  이후 멀웨어는 루틴에 대한 등록된 모든 콜백을 제거한다.

					3. 모니터링되지 않는 진정한 악성 프로그램이 실행된다.



				콜백 제거 예시 http://rcecafe.net/?p=116http://rcecafe.net/?p=116 


				커널 모드 드라이버는 시스템에서 발생하는 모든 인/아웃풋 및 트랙잭션 활동을 모터링하고 기록하는데 사용할수 있는 기능을 제공한다. 

				커널 단게 멀웨어는 APC_LEVEL(비동기 프로 시저 호출), DISPATCH_LEVEL( 지연 프로시저 호출이 일어나는곳)과 같이 PASSIVE_LEVEL(미니 필터가 작동 하는곳) 보다 낮은 레벨에서 수행 가능



				


-C10- 공격 식별? 
		
	로컬 공격에 필요한 개념

	1. 파일 및 디렉토리에 대한 권한 

	2. unix 기반 플랫폼에서 사용자 ID, 또는 그룹 ID 바이너리 설정
	
	3. ASLR, 및 DEP

	4. windows 객체에 대한 잘못된 권한
	
	5. 로지컬 에러

	6. 루프팩 어댑터에서 수신하는 네트워크 서비스 ( localhost )

	7. 커널 장치 드라이버 

	
	[1] 권한 취약점 --> 적어도 네이버 백신에는 존재 하지 않음.
	 
		2008년 panda 안티바이러스는 권한 설정이 잘못되어있었고 공격자는 pavsrv51.exe 와 이름이 같은 악성 코드를 이용해 공격이 가능했다.
		
	[2] incorrect ACL(access control lists)

		팬더 바이러스 백신은 NULL ACl 값을 프로세서로 할당하고 모든 로컬 사용자가 모든 작업을 수행할수 있게 만들기도 하였다. CreateRemoteThread API를 사용하여 DLL을 두 프로세스 중 하나에 주입하고 System 권한을 쉽게 얻을수 있었다. 

	----* 1과 2는 비슷한 내용임		

	[3] 커널 단계 취약점

		커널레벨 단에서 CreateFile에 훅을 설치하는데 이런 훅 함수를 사용할때 주의를 해야하지만 API 훅 처리를 잘못함으로 일어난 취약점이 빈번하다. NJ0011은 후크된 드라이버가 API로 인수를 전송하는 부분에서 오버플로우 취약점을 찾았다.

	[4] 이국적인 버그? [exotic bugs]
	
		Arash Allebrahim 의 오버플로우 취약점, 이 취약점은 스캔하는 도중 		아주 긴 이름의 파일 때문에 일어났다고 한다.

	[5] SUID SGID 에 대한 설명과 이에대한 루트 취약점 사례 이 부분은 따로 요약하지 않겠습니다. 기술적인 내용이 아닌 사례를 설명하기 때문에

	[6] ASLR 같은경우 윈도우는 컴파일 할때 설정해준다. 즉 에전에 나온 버전 혹은 패치가 이루어지지 않은 파일에 대해서는 공격이 쉬워진다.

	[7] ASLR과 DEP가 걸린것을 확인하려면 Process Explorer 를 사용하면 된다. 
	
	[8] 대부분의 라이브러리, 주 프로그램은 ASLR을 걸수없다. 기본 주소 로드와 충돌 현상이 있다고 한다 [ 이 부분은 번역이 완벽하지 않다. ] 


	[9] winobj.exe 권한 설정하는데 도움이 된다. 네이버 백신 같은경우 기능이 들어있는 BaseNamedObjects 라인에 가면 있다. 여기서 권한을 보고, 커널 오브젝트를 알 수 있다. 특정 권한도 볼수 있다. 여기서 설정된 권한 문제로 이벤트를 받지 않는 프로세스에게 이벤트를 계속 전송함으로서 서비스 거부 공격까지 이어질수 있다. 이 문제에대한 제일 큰 권한 문제는 권한을 부여하지 않음으로써 (즉 ACL에 아무것도 등록하지 않는 문제) 누구나 이 목록에 접근할수 있기 때문이다. 때문에 dll createremoteTread를 호출하여 dll을 인젝션 시킬수 있다고 한다. ( 취약함 함수는 setsecurityDescriptorDAL 이다 프로그래머는 이 기능을 호출 함으로서 쉽게 코딩 하려고 하는 경향이 있다고 한다. 하지만 이렇게 되면 다른 로컬에 있는 모든 사람이 같은 권한으로 동일 작업이 가능해지기 때문에 위 실험이 통하게 된다. ) 

	[10] 로지컬 에러 버그 : panda 백신 같은경우 시스템 서비스로 쉘 코드를 죽이거나 삽입하는 것을 방지 했는데 이 기술은 어떤 로지컬한 이유로 이 기능에 on off 기능을 만들어 버렸다. 이때 disable 하는 uuid key 를 주석 처리하여 숨겨 놨다. 이는 IDA로 분해를 했을때 확인 할수 있는 값이다.


	[11] 원격 공격 

		- 이에 대해 공부를 하려면 총 6가지의 기능에 대해 알고 있어야 한다. 

			1. 다양한 파일 형식 파서

			2. 일반 탐지 및 치료 코드 

			3. 네트워크 서비스, 관리 패널 및 콘솔 

			4. 브라우저 플러그인
			
			5. 방화벽, 칩입 탐지 시스템 및 다양한 네트워크 프로토콜 파서 

			6. 서비스 업데이트 

		- 바이러스 백신 제품은 원격 악의적인 공격을 유발 할수 있는 거의 모든 진입점을 보호하려고 한다. 하지만 결과적으로 이런 보호를 해주는 프로그램이 생기면 생길수록 공격 벡터가 상당히 많이 존재 하게 된다고 한다. 예를 들어 패킷 필터 드라이버를 도입한다면 이는 네트워크 프로토콜을 통해 새로운 공격 벡터를 만들수 있다. 다음섹션에선 이러한 네트워크 관련 해킹에 대해 설명한다. 


	[12] file 파서 

		- file 파서는 원시코드에서 비교적 복잡한 zip, 7z, pdf 상당히 복잡한 문서에 대해 파싱을 할때 에러가 많이 나온다고 한다.

	[13] 일반 탐지 및 감염파일 제거 코드 

		감염된 파일 같은경우 읽을때 크기, 오프셋, 공격자가 제어하는 다른필드가 백신이 분석하는 어딘가 저장이 될거고 이 부분말 제거를 할것이다 하지만 이 부분에서 memcpy 와 같은 함수를 쓰고 버퍼의 크기를 계산 하지 않으면 오버플로우가 일어날수 있다. 

	[14] 네트워크 서비스, 관리 패널 및 콘솔 

		- 누락된 인증 

		- 누락 된 엔터티 인증 

		- 정적 암호화 키 및 안전한지 않은 작동 모드 

		- 원격 코드 실행 

			-> 클라이언트에서 서버로 전송 된 매개 변수 중 하나가 서버에 의해 로드 DLL에 대한 경로 였다. 


 	[15] 방화벽 및 침입탐지 시스템
		
		- 여러 네트워크 프로토콜 ip tcp http 등과 같은 패킷에서 악성 코드를 검출 하기 위해 자체 파서를 사용할것이고 분석 하는 구문에서 단일 취약점이 있을수도 있다. 


	[15] 업데이트
	
		- 업데이트를 받는 도중 트래픽을 스니핑 하여 파일을 바꿔 받게 한다. 뒤에서 논의 된다고 한다. 이부분에 대해선

	[16] 브라우저 플러그인 
		- 액티브 엑스 관련 버퍼 오버플로우가 존재 했었다. 액티브 엑스가 왕성하던 시절 브라우저 전용 작은 크기의 안티 바이러스 제품이 있었는데 이는 설계적으로 많이 위험한 코드가 많이 존재 했다고 한다.

	[17] 향상된 보안 소프트 웨어 

		- 보안 기능이 들어간 브라우저 [ 우리는 브라우저에 대해 할것이 아니므로 제거 ] 


-C11- 서비스 거부 공격 

	1. 압축 폭탄 

		내부에 많은 압축 파일을 가지고 있어 검사하면서 엄청난 자원 사용률을 차지한다. 이렇게 되면 백신은 작동을 중지하게 되고 공격자는 원하는 악성 코드를 삽입 및 실행을 유연하게 할수있게 된다. 
	
		1.간단한 압축 폭탄 bzip 

			$LANG=C dd if=/dev/zero bs=2048M count=1 | bzip2 -9 | wc -c     --> 리눅스에서 가능


		2.간단한 압축 폭탄 7zip 

			$ LANG=C dd if=/dev/zero bs=2048M count=1 > 2gb_dummy
			$ 7z a -t7z -mx9 test.7z 2gb_dummy
			$ du -hc test.7z 



	2. 파일 포맷 파서 버그

		1. 파일 형식 에러로 인한 백신이 작동을 안함, 이렇게 되면 하위 디렉토리에 숨어있는 백신을 못찾게됨


	2. 커널 드라이버 도스 

		로컬 사용자가 버그를 사용해 프로세스와 통신, 트리거를 할수 있는 경우 블루 스크린을 작동시켜 효율적으로 재부팅 시킬수 있따. 커널 드라이버에서 발견되는 대부분 일반적인 취약성은 수신된 인수가 올바르게 검사 되거나 검증되지 않는 IOCTL 이다. 


	3. 원격 DOS 공격 
		
		1. 압축 폭탄 

		2. 로컬 형식의 서비스 거부와 마찬가지로 파일 형식 파서 버그 

		3. 네트워크 프로토콜 파서 버그 

		4. 루프백 네트워크 인터페이스 이외의 네트워크 인터페이스를 수신하는 바이러스 방지 네트워크 서비스에 대한 공격


		5. 압축 폭탄 ( 메일 ) 

			1.공격자는 압축 폭탄을 메일로 보낸다. 

			2. 백신은 파일을 받자마자 분석에 들어간다.

			3. 공격자는 이전 전자 메일을 보낸 직후에 다른 전자 메일을 멀웨어와 함께 보낸다. 

			4. 바이러스 백신 제품이 이전 파일을 분석하는 동안 의심하지 않는 사용자가 공격자가 보낸 두 번째 전자 메일에 첨부 파일을 열어 감염됨. 자연스럽게 이 공격 시나리오는 각 바이러스 백신 제품과 e-메일 클라이언트의 동작 방식에 따라 달라지게된다. 



	5. 파일 형식 파서 버그 


		1. 공격자는 바이러스 백신 소프트웨어의 서명을 만드는 악의적인 웹페이지 제작
	

		2. 취약한 바이러스 백신이 탐지되면 공격 서버는 바이러스 백신 스캐너에서 충돌을 일으키는 파일을 가리키는 iframe이 포함된 웹 페이지를 전송, 이후 여러 파일을 충돌이 일어날때까지 전송해
	
		3. 몇 초후 웹 브라우저의 취약점으로 자바 스크립트 실행 

		4. 탐지 불가능 



-C12- 정적 분석


	
	
	
	1. File Format Parsers 


		- nm 명령어로 심볼을 확인하려고 해도 심볼이 날아간 상태에서 readelf 명령어로 심볼을 확인할수있다. 이후 egrep -i "(packer|compress|gzip|bz2)" | more 명령어를 통해 심볼을 보면 IDA로 분석했을때 심볼이 안날라 갈수 있다는것을 보여준다. 


		- 이후 취약점을 찾기 위해 malloc , free 같은 메모리를 건드는 부분부터 탐색 하기 위해 함수를 사용하는 부분을 찾아 분석한다. IDA에서 x 키로 호출 가능한것 같음 


		- 책에 나온 취약점은 멀록에서 공간을 할당할때 memset 사용 부분에서   unsigned int 로 선언된 값에 size 라는 인자를 -1 수정해주면 0xFFFFFF~ 가되는데 Dest 의 주소부터 끝까지 0으로 덮이면서 시그 폴트 에러를 띄어준다. 


		
	2. remote service

		- 이 부분은 리눅스 버전 취약점을 찾는 관계로 따로 깊게 정리하지 않겠습니다. 

		- SUID에 관한 취약점 이었음 

		- php 코드와 관리자 권한을 사용하는 구문 에서 취약점이 발생, 


-C13- 동적 분석 ( 양 개많음 )  







-C14- 


-C15- 


-C16-


-C17-

	
	
	
