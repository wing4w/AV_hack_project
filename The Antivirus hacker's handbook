번역이 불안정해 미완성 [*] 


-C1-  요약

	self-protection
	-커널 단계 에서 자체 구현 하는 백신이 많음 
	-일부 백신은 유저 단계에서 구현한다.
	
	AV는 커널 단계에서 사용하는 기능이 들어가있음
	검색엔진, 서명, 압축풀기, 에뮬레이터 지원

-C2- 리버싱

	사용 툴 : IDA, IDA python, windbg, gdb, winelib, bindiff, pydbg[*] 

	IDA : 정적 분석에 사용
	IDA python : 자동화
	windbg : 동적 분석에 사용
	gdb : 리눅스 버전 동적 분석	
	winelib : 리눅스 버전에서 동적으로 커널 드라이브 분석할때 사용
		  { 시리얼 통신 }
	bindiff : 바이너리 비교 툴 
		  { 리눅스에서는 심볼이 살아있을수도 있음 이걸 windows 버전으로 옮겨서 쉽게 분석 }
	

	백신 일부는 중압 집중식 서버에서 실행하게 설계 되어있음
	
	커널 디버깅을 위해 가상머신을 사용한다 -> 운영체제 부팅 옵션 제한
	
	bcdedit /debug on : 커널 디버깅 사용
	bcdedit /dbgsettings serial debugport:1 baudrate:115200 : 글로벌 디버깅 설정 및 시리얼 통신 속도 설정
	
	가상 머신에서 시리얼 통신 포트를 개방 해줌 COM1 포트	
	- COM1 포트와 가상머신 커널 통신

	.sympath srv*http://msdl.microsoft.com/download/symbols
	.reload
	-> windbg 재로드
	
	!process 0 0 -> 커널단 프로세서 나열

	!process 0 0 fssm32.exe -> 이름으로 나열 
	--> PROCESS [주소] : [주소]는 eprocess 의 구조체

	.process /r /p [eprocess] -> 모든 심볼 나열

	
	[ 퍼징은 리눅스에서 더 빠름 ] 

	

	대부분의 안티 바이러스는 서버로 파일의 해시검사 하고 전송해 파일이 악성 코드인지를 검증
	이때 통신 소켓 파일을 찾아 소켓을 생성하고 직접 파일의 해시를 전송함으로서 백신 서버와 통신 가능

	
-C3- 플러그인 로딩

	플러그인 로딩은 R,W,X 메로리 페이지에 할당된다. 
	
	할당된 메모리가 적절하다면 내용과 해독 및 압축을 해제 한다. 

	이후 쓰기권한을 삭제한다, 또한 플러그인을 dll 파일로 제공하여 단순화 시킨 데이터를 난독화 시킨다. 
	
	-memory Scanners 
		userland = openPorcess, ReadProcess memory : win32API 를 사용하여 제공한다.
		kernel = IOCTL : AV 회사가 직접 만ㄷ르어 사용해야함

	플러그인은 스크립트로 작성될수있음 => lua script, .net
	커널 드라이버는 C or C++, 일부는 .net

	.net 으로 작성되어있으면 머리가 아파진다고 한다. 이에 대한 방법
		- 1. 코드가 가상시스템용인지 식별 한다.
		- 2. 가상 컴퓨터가 지원하는 전체 명령 집합 확인
		- 3. 플러그인의 루틴 바이트가 위치한곳을 덤프
		- 4. 특정 가상파일에 구현된 플러그인 분석 시작


-C4- 안티 바이러스 시그니쳐의 이해

	우회방법 1. 서명에 1byte를 추가 하는 방법 ( 해시를 비교하는 부분 우회 ) : 해싱 비교 기법 : ssdeep 프로그램 동작 방식 사용 
	


	
