번역이 불안정해 미완성 [*] 


개인적으로 윈도우7에 설치할 프로그램 목록

 1.IDA		2.x64dbg, windbg 	

 3. PE 분석툴 [ 아래는 목록 ]

 - PEView (무료, 데이터 수정 불가능)
 - PE Explorer (상용)
 - Stud PE (무료, 데이터 수정 가능)
 - PE Browse (무료, 데이터 수정 불가능)


최근 수정 : 2018/09/05 

-C1-  요약

	self-protection
	-커널 단계 에서 자체 구현 하는 백신이 많음 
	-일부 백신은 유저 단계에서 구현한다.
	
	AV는 커널 단계에서 사용하는 기능이 들어가있음
	검색엔진, 서명, 압축풀기, 에뮬레이터 지원

-C2- 리버싱

	사용 툴 : IDA, IDA python, windbg, gdb, winelib, bindiff, pydbg[*] 

	IDA : 정적 분석에 사용
	IDA python : 자동화
	windbg : 동적 분석에 사용
	gdb : 리눅스 버전 동적 분석	
	winelib : 리눅스 버전에서 동적으로 커널 드라이브 분석할때 사용
		  { 시리얼 통신 }
	bindiff : 바이너리 비교 툴 
		  { 리눅스에서는 심볼이 살아있을수도 있음 이걸 windows 버전으로 옮겨서 쉽게 분석 }
	

	백신 일부는 중압 집중식 서버에서 실행하게 설계 되어있음
	
	커널 디버깅을 위해 가상머신을 사용한다 -> 운영체제 부팅 옵션 제한
	
	bcdedit /debug on : 커널 디버깅 사용
	bcdedit /dbgsettings serial debugport:1 baudrate:115200 : 글로벌 디버깅 설정 및 시리얼 통신 속도 설정
	
	가상 머신에서 시리얼 통신 포트를 개방 해줌 COM1 포트	
	- COM1 포트와 가상머신 커널 통신

	.sympath srv*http://msdl.microsoft.com/download/symbols
	.reload
	-> windbg 재로드
	
	!process 0 0 -> 커널단 프로세서 나열

	!process 0 0 fssm32.exe -> 이름으로 나열 
	--> PROCESS [주소] : [주소]는 eprocess 의 구조체

	.process /r /p [eprocess] -> 모든 심볼 나열

	
	[ 퍼징은 리눅스에서 더 빠름 ] 

	

	대부분의 안티 바이러스는 서버로 파일의 해시검사 하고 전송해 파일이 악성 코드인지를 검증
	이때 통신 소켓 파일을 찾아 소켓을 생성하고 직접 파일의 해시를 전송함으로서 백신 서버와 통신 가능

	
-C3- 플러그인 로딩

	플러그인 로딩은 R,W,X 메로리 페이지에 할당된다. 
	
	할당된 메모리가 적절하다면 내용과 해독 및 압축을 해제 한다. 

	이후 쓰기권한을 삭제한다, 또한 플러그인을 dll 파일로 제공하여 단순화 시킨 데이터를 난독화 시킨다. 
	
	-memory Scanners 
		userland = openPorcess, ReadProcess memory : win32API 를 사용하여 제공한다.
		kernel = IOCTL : AV 회사가 직접 만ㄷ르어 사용해야함

	플러그인은 스크립트로 작성될수있음 => lua script, .net
	커널 드라이버는 C or C++, 일부는 .net

	.net 으로 작성되어있으면 머리가 아파진다고 한다. 이에 대한 방법
		- 1. 코드가 가상시스템용인지 식별 한다.
		- 2. 가상 컴퓨터가 지원하는 전체 명령 집합 확인
		- 3. 플러그인의 루틴 바이트가 위치한곳을 덤프
		- 4. 특정 가상파일에 구현된 플러그인 분석 시작


-C4- 안티 바이러스 시그니쳐의 이해

	우회방법 1. 서명에 1byte를 추가 하는 방법 ( 해시를 비교하는 부분 우회 ) : 해싱 비교 기법 : ssdeep 프로그램 동작 방식 사용 
	

-C5- 업데이트 시스템

	서명을 다운로드할땐 http, https, 간혹가다 ftp[오래된 제품] 
	
	해시를 보고 오래된 버전과 새로운 버전을 구별하여 다운로드 받음
	책에선 해시만 다르면 다운로드 받는다고 적혀있음

	ssl 통신 중 가능한 공격 기법
	
	1.domain name system 변경 가능할때 
	- > 당연하게도 악의적인 파일 다운로드 시킴
	
	2. MITM
	- > 같은 네트워크 망에 있으면 파일을 수정 하여 공격가능 

	

	ssl 통신 중 발견될수 있는 취약점
	- > server 의 인증서 호가인 없이 SSL/TLS 사용
	- > CA 인증기관이 없을경우 [자체 적인 사용] --> MITM 가능
	- > 유효 하지만 만료된 인증서 수락 

	[Verifying the Update Files]
	- > 번역문제 때문에 보류

	업데이트 패킷 조사
		1. 와이어 샤크로 패킷 캡쳐

		2. xml 파일과 대조

		3. 프로토콜 분석

		4. 취약점 탐색[서명 체크] 

	보안을 신경쓰지 않은 업데이트는 인증서 관련 공격에 취약할 수 있음
	예전 사례로 디피 헬만 키교환이 8비트로 구성되어 쉽게 공격이 가능


-C6- 안티 바이러스 소프트웨어 우회 


	바이러스 탐색 기법
	1. 알려진 바이러스 해시 검사
	2. PE헤더 조사 --> 오프셋 으로 검사함 내용이 추가 되어 있는지
	3. 인스트럭트 검사



-C7- 전자서명 우회방법
	1. 바이러스인지 탐색하는 부분에서 로지컬 에러를 찾는다. 책에선 사이즈를 비교하는 분기문을 통과 시켰다. 
	[PE]
		-PE file 
			- PE 파일은 다른 프로그램 없이 자체적으로 실행 가능한 프로그램을 말한다.
			- [오역 일수도 있음] PE 파일은 파일자체를 손상시키지 않고 변경할 수 있는 방법이 많다.
		[section name]
			바이러스 검사시 섹션 네임을 보고 검사를 하는 백신이 존재한다. 이 부분을 수정할수도 있는것 			  같다.
		[TimeDateStamp] 
			시간으로 바이러스 탐지 증거로 사용하지만 이 타임데이트스탬프 영역은 마음대로 변경가능하고 			  NULL로 변경 까지 가능하다.
		[Major/Minor operatingSystemVersion]
			이 친구는 타임데이트스탬프와 완전히 일치한다고 합니다.
		[File Length]
			파일이 비정상적으로 크면 어떤 백신은 검출을 무시하기도 함, 이유는 대부분의 바이러스가 용량			  이 작기 때문임 

		[****] PE탐지 우회는 정말 많은 방법이 있다. 때문에 작성자도 Ange Albertini의 wiki를 확인하란다.


	2. 자바 스크립트 
		많은 악성 코드들은 자바 스크립트로 제작 되어 있음
		
		첫번째로 문자를 인코딩 하는 방법이다. XSS,Sql injection 등 우회 방법과 동일	
		
		두번째로 코드 삽입 기술이다. 많은 문자열을 입력받고 실행하는 코드가 존재하기 떄문에 이런 방법도 된		  다고 한다.
		
		세번째는 자바스크립트 로지컬에러 정크코드 실행 부분인데 이해가 안간다. 번역이 어렵다; [*]

	3. PDF
		-1.PDF는 엄청난 헤더와 크기 떄문에 안티 바이러스에서 검출이 사실상 불가능하다.
                 때문에 hash 검사하는 기법을 사용한다. 
		pdf에 사용되는 공격코드는 자바스크립트가 대부분 유형이며 자바스크립트의 모든 문자열을		    		  인코딩 시켜서 올리는 방법이 있다. 이렇게 되면 hash는 달라질것이고 우회가 가능하게 된다. 
		
		-2. PDF 우회 [number] [number2]  obj  ~~~ endobj 형식으로 구성되는데 [number]가 동일하다면 맨 아래 		      선언된 형식을 따라간다. 이런 중복 오브젝트 방식을 백신이 이해하지 못하고 있다면 이부분에 쉘 코			드를 추가하여 공격이 가능하다. 
		    
		--> 이 파트는 스캐너 탐지가 아닌 서명 탐지를 우회하는 기법이다 


	    


	
	
-C8- 스캐너 우회방법

	들어가기 앞서 7장은 서명을 우회하는 방법이라면 8장에서는 PE파일 전체를 우회하는 방법에 대해 논하는 부분이	  다.
	
	finger printing -> 이 부분은 comodo 안티 바이러스 기능중 지문인식 암호화 부분을 말하는데 이 부분은 따로
	요약을 하지 않았습니다.
	

	Target : ClamAV의 PE parser 모듈

		- windows xp 버전에서는 PE 파일에 섹션이 96개 이상 존재하면 PE 파일이 깨진상태로 인식한다.
		  windows vista 버전으로 넘어오면서 섹션의 크기는 커졌고 이에 대한 대응이 없었던 백신은 취약점			    이 생기는 부분을 노렸다.

	안티 에뮬레이터 : [*] 이해를 못하겠습니다. # anti emulator 공부 요망

				1.windows 에서 기본 제공하는  SetErrorMode() 함수를 통해 안티 에뮬레이팅을 했다. 
				[고전적인 방법] -> SetErrorMode 를 한번 선언하고 재호출 하는 코드는 안좋은 코드다
				--> 잘못된 구현 코드를 설명 하는듯 하다.
				또한 null 값을 매개 변수로 특정  API 트리거에게 전달하면 에뮬레이트 되지 않은 환경
				에서는 액세스 위반 예외처리가 된다. 
				
	8장은 회의후 질문 내용을 추가하여 다시 적을 예정입니다. 






-C9- 지능형 엔진 우회 방법
	
	
	
		휴리스틱 알고리즘 : 휴리스틱 알고리즘은 가용한 정보를 기반으로 분기단계에서 어느 한 분기를 선택 하기위해 사용하는 다양한 탐색 알고리즘의 대안 함수 
		

		휴리스틱 엔진 및 백신에서의 휴리스틱 정의 : 휴리스틱이란 백신에 정의 되어 있지 않은 악성 코드 외에 악성 행위를 하는 코드를 탐색하고 진단하는 기능이다. 정의가 되어있지 않으므로 오탐률이 높다고 한다.
	
		휴리스틱 엔진은 크게 정적, 동적, 하이브리드 방식과 같은 3가지 유형이 존재함 

		책에서는 두 가지 전략을 모두 사용하는 방면으로 접근을 시도, 정적인 휴리스틱 엔진이 흔히 말하는 휴리스틱 엔진이며 동적으로 탐지하는 휴리스틱 엔진은 HIPS 라고 한다. 

		정적인 방법에서는 헤더를 분해하고, 분석하고 증거를 정적으로 발견한다.
		동적인 방법에서는 프로그램 동작 부분에서 API 호출을 주로 본다고 한다.

		


		1.  정적인 휴리스틱 엔진
		
			정적인 휴리스틱 엔진은 다양한 방법으로 구현됩니다.
			
			컴퓨터에 학습 알고리즘을 구현하여 유사성에 대한 정보를 기준으로 탐색하는 기법 --> 이 기법은 크기가 큰 멀웨어를 타겟으로 만들어졌습니다. 하지만 이러한 클러스팅으로 제작된 휴리스틱 엔진은 오탐률이 높고 큰 컴퓨팅 자원을 소비해서 그다지 성능적으로 좋지 않은것을 말하고 싶은것 같다.

			
			두번째 알고리즘은 사람의 의지가 들어가는 엔진이다. 간단하게 헤더를 분석하고 난독화, 안티디버깅 같은 기술들이 들어가 있고 프로그램이 자체를 보호하려고 한다면 사용자에게 이 프로그램을 사용하거나, 압축이 되어있거나 이런 정보를 물어보고 이러한 사람의 판단, 경험을 기준으로 제작하는 알고리즘이 있다.

		
			본 저자는 comodo 백신을 기준으로 linux 에서 ida로 분석을 시도했고 심볼은 libHEUR.so에 구현되어있다. 때문에 심볼을 살려 분석이 가능했고 이 토대로 분석을 시작한다.


			저자는 SCANHEUR 함수 부분을 추적 했고, 코드 부분이 어떠한 파일은 언패킹을 열심히하는 부분을 찾게 되었다. 찾던 도중 화이트 리스트가 하드 코딩된 부분과 대조를 하여 판별 하는 부분이 있는데 이 부분을 찾아 악성코드 PE 에 추가 해주면 간단히 우회가 가능했다. 
			

			두번째로 우회해야 하는 부분은 슈도 코드에서 나오는 확장자를 검사하는 부분이다. 
			하지만 이 부분은 하드 코딩 되어있기 때문에 .cpl 과같은 확장자로 하드코딩에 없는 실행 파일로 쉽게 우회 가능하다.

			
	

		2. 동적인 휴리스틱 엔진 

			동적인 휴리 스틱 엔진은 OS에서 제공하는 API에 의존해 성능이 크게 좌우 된다고한다.
			또한 CPU 에뮬레이터 의 성능도 많이 좌우 한다고 한다.

			일반적으로 HIPS 과 같은 후크 기반 휴리스틱을 우회 하는 방법은 쉽지만 API 훅이 설치된 레이어에 따라 난이도가 결정 되는것 같다. 프로그램 동작을 모니터링 하기 위해 훅을 설치하는 두가지 방법이있다. userland 훅과 kernel land 훅이 있다고 한다. 둘다 장단점이 존재한다.



			Userland - Hooks :
				
				많은 안티 바이러스 제품은 사용자 영역 후크를 사용해 실해중인 프로세스 실행을 모니터링한다. 후킹은 windows API 중 createfile, createPorcess와 같은 일반적인 API를 우회하는 것으록 구성 된다.

				Hooking engine :
							madcodeHook - delphi 로 작성됨, 다양한 런타임 지원, commod, McAfee 백신에서 사용됨

							EasyHook - 오픈소스 후킹 엔진이다, 좋은 성능과 완성도를 자랑하며 일부 바이러스 백신은 이 엔진을 사용하고 있다.

							Detours - 마이크로소프트 리서처의 독점적인 후크 엔진이다 소스코드를 사용할수 있지만 라이센스 구매를 해야하며 상업 제품 일부는 이 엔진을 사용하고 있다.

							하지만 이런 후킹엔진이 어느 백신에 쓰이는지는 무의미하다고 한다. (그럼 왜 알려준걸까..?)



				API 훅 처리 순서 :
						

							1. 모니터링을 원하는 사용자 프로세스에 라이브러리 주입 일반적으로 후킹 라이브러리는 모든 프로세스에 주입되므로 사용자 영역 프로세스를 시스템 차원에서 모니터링 한다. 


							2. API를 처리하기위한 바이러스 백신 코드를 함수의 첫번째 어셈 명령어를 점프로 대체 한다.

							3. API에 대한 바이러스 백신 코드 후크가 실행된다.

							4. 후크가 실행된 후 원래 코드로 돌려준다.

				과거 안티바이러스 후킹 라이버르리, 또는 주입할 라이브러리를 Appinit_dll 레지스트리 키를 사용하는것이었다. 이 레지스트리 키에는 삽입할 DLL에 대한 경로가 들어있고 user32.dll을 가져오는 모든 프로세서에 주입하는것 같다. 
				

				두번째 인기 있는 방법은 windows 데스크톱 시작시 바이러스 백신 프로그램 구성 요소를 실행하고 createremoteTread를 통해 explorer.exe 프로세스에 코드를 삽입 한다음 CreateProcessInternal 함수를 연결 한다. 이때 이함수는 새 프로세스를 만들려고 할때마다 실행 하게 된다. 하지만 이 API는 연결 형식이라 후킹 DLL이 새프로그램의 메모리 공간에 주입하도록 설계 되어있다. 하지만 이 기술은 createremoteTread API의 제한으로 인해 모든 새 프로세스가 모니터링 될거라고 보장 할수가 없다, 하지만 이럼에도 불구하고 이 방법은 다양한 바이러스 백신 제품에서 계속 사용된다고 한다. 

				DLL을 주입하기 위한 마지막 전형적인 접근법은 커널 랜드에서 수행하는 기법이다. 커널 랜드에서 psSetcreateProcessNotifyRoutineEx 콜백을 등록하고 모든 새 프로세스에 대해 커널 랜드에서 userland 코드가 들어간 dll을 주입하는 기법이다. 

				어쨋든 모든 후킹 엔진은 어떻게 뿌려주는지에 관계없이 동작은 거의 비슷하기 때문에 이를 우회하는 보편적인 기술을 개발할수 있다고한다. 


				이 우회 기술은 함수의 프롤로그를 덮어서 바이러스 백신 대체 기능으로 이동해야 하므로 변경 사항을 간단히 돌릴수 있고 또한 hook을 취소 할수도 있다고 한다. 이 개념을 명확하게 설명하기 위해서는 프레임 기반 함수의 프롤로그는 동일한 바이트 코드 시퀀스 또는 기계어가 있음을 알아두는게 중요한다. [ 난 이게 도대체 무슨 말인지 모르겠다. 아래있는 푸시 이비피 무브 이비피 이에스피를 알아야한다는건지 잘 모르겠다. ]


				후킹을 취소하는 빠른 방법중 하나는 바이트 시퀀스를 하드 코딩 하는 방법이라고 한다. 우회 코드에서 프롤로그 기능을 수행 한다음 함수의 시작 부분을 덮어 쓰는 방법이다. 하지만 이 프롤로그와 후킹된 함수의 프롤로그가 다른 경우 이러한 방법은 실패할수도 있다고 한다. 


				후킹 취소 하는 방법:

					1. 디스크에서 kernel32.dll, ntdll.dll 등 원본 라이브러리를 읽어옵니다. 
					2. 라이브러리에서 후킹 된 함수의 주소를 알아낸다. 이때 dbgeng.dll을 사용하여 알아 낼수 있습니다. dll export 테이블을 보고 주소를 찾아낸다.				
					3. 알아낸 함수의 초기 바이트를 읽는다. 


					4. 원래 바이트를 다시 메모리에 쓴다. 바이러스 백신이 패치를 알수 있습니다? [ 이부분 뭔말인지 모르겠음 ] 이에 대한 대안으로 첫 번째 명령어를 읽어 온다. 그 파일을 원래의 코드를 다시 이동하면 된다. [ 그냥 함수의 바뀐 바이너리를 원래 바이너리로 바꿔주면 된다는 내용 같다. ] 




				



				

				







			kernel-land - Hooks :

			


	
		


					
